<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Java8的Lambda表达式与类型检查、推断及限制 - Tomial's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:image" content><meta property="og:title" content="Java8的Lambda表达式与类型检查、推断及限制"><meta property="og:description" content="为了全面了解Lambda表达式，我们应该知道Lambda的实际类型是什么。 类型检查 Lambda的类型**是从使用Lambda的上下文推断出来"><meta property="og:type" content="article"><meta property="og:url" content="https://tomial.github.io/posts/java8%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%8E%A8%E6%96%AD%E5%8F%8A%E9%99%90%E5%88%B6/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-23T22:12:15+00:00"><meta property="article:modified_time" content="2019-04-23T22:12:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java8的Lambda表达式与类型检查、推断及限制"><meta name=twitter:description content="为了全面了解Lambda表达式，我们应该知道Lambda的实际类型是什么。 类型检查 Lambda的类型**是从使用Lambda的上下文推断出来"><script src=https://tomial.github.iojs/feather.min.js></script><link href=https://tomial.github.iocss/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://tomial.github.iocss/main.css></head><body><div class=content><header><div class=main><a href=https://tomial.github.io>Tomial's Blog</a></div><nav><a href=/>主页</a>
<a href=/posts>全部文章</a>
<a href=/tags>标签</a>
<a href=/about>关于</a></nav></header><main><article><div class=title><h1 class=title>Java8的Lambda表达式与类型检查、推断及限制</h1><div class=meta style=margin-bottom:3em>最后编辑于 2019-04-23</div></div><section class=body><p>为了全面了解Lambda表达式，我们应该知道Lambda的实际类型是什么。</p><h2 id=类型检查>类型检查</h2><pre><code>Lambda的类型**是从使用Lambda的上下文推断出来的**。上下文(即`接受它传递的方法参数`或`变量`)所需要的类型称为`目标类型`。下面的例子说明了Lambda表达式工作时**类型检查**的过程：
</code></pre><div class=highlight><div style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java>List<span style=color:#5bc4bf>&lt;</span>Apple<span style=color:#5bc4bf>&gt;</span> heavierThan150g <span style=color:#5bc4bf>=</span>
    	filter<span style=color:#5bc4bf>(</span>inventory<span style=color:#5bc4bf>,</span> <span style=color:#5bc4bf>(</span>Apple a<span style=color:#5bc4bf>)</span> <span style=color:#5bc4bf>-&gt;</span> a<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getWeight</span><span style=color:#5bc4bf>()</span> <span style=color:#5bc4bf>&gt;</span> 150<span style=color:#5bc4bf>);</span>
</code></pre></td></tr></table></div></div><ol><li><p>使用Lambda的<strong>上下文所需的目标类型</strong>是什么？</p></li><li><p>可以看看filter的定义：<code>filter(List&lt;Apple> inventory, Predicate&lt;Apple> p)</code></p></li><li><p>可以知道<strong>目标类型</strong>为<code>Predicate&lt;Apple>(T绑定到Apple类)</code></p></li><li><p><code>Predicate</code>接口定义的<strong>抽象方法返回类型</strong>是什么？</p></li></ol><p>-><code>boolean test(Apple apple)</code>得到抽象方法为test，接收一个<code>Apple类型参数</code>并返回一个<code>boolean</code>值</p><p>-><code>(Apple a) -> a.getWeight() > 150</code><strong>函数描述符</strong><code>(Apple) -> boolean</code>匹配Lambda表达式，表示接收了一个<code>Apple参数</code>并返回一个<code>boolean</code>值。<strong>类型检查无误；</strong></p><blockquote><p>注：这里的函数描述符指的是抽象方法描述的Lambda表达式，包含了方法需要的参数列表和返回类型。如：(type 1, type 2, &mldr;) -> return type，在上文中则为(Apple) -> boolean</p></blockquote><p>当Lambda表达式抛出一个异常时，抽象方法所声明的throws语句也需要与之相匹配。</p><h3 id=将相同的lambda表达式作用于不同的函数式接口>将相同的Lambda表达式作用于不同的函数式接口</h3><p>由上文可以知道，不同的参数或变量只要有兼容的**目标类型，**Lambda表达式就可以作用于他们。比如</p><p><code>Callable</code>接口和<code>PrivilegedAction</code>接口都拥有一个不接受参数而返回泛型T的抽象方法。所以下面的赋值就是有效的：</p><p><code>Callable&lt;Integer> c = () -> 42;</code></p><p><code>PrivilegedAction&lt;Integer> p = () -> 42;</code></p><p>第一个赋值语句的目标类型是<code>Callable&lt;Integer></code>，第二个是<code>PrivilegedAction&lt;Integer></code></p><p>对void抽象方法的特殊兼容：</p><blockquote><p>当Lambda的主体是一个语句，它就和一个返回void的函数描述符兼容。</p><p>如list.add(a)返回值一个boolean值</p><p>下面的语句是可行的：</p><p><code>Predicate&lt;String> p = s -> list.add(s);</code> //Predicate的抽象方法返回一个boolean值</p><p>下面的语句也是兼容的：</p><p>Consumer c = s -> list.add(s); //Consumer的抽象方法返回一个void值</p></blockquote><h3 id=类型推断>类型推断</h3><p>Java编译器<strong>可以推断适合的Lambda的签名</strong>，因为Lambda的签名是由函数描述符得到的(即函数式接口的抽象方法)。比如下面的例子：</p><p>`List greenApples = filter(inventory, a -> “green”.equals(a.getColor()));</p><p>例子里面的<strong>参数a并没有指定它的类型</strong>，Java编译器可以<strong>自动推断出它的类型</strong>，Lambda只有一个参数时可以省略括号。</p><p>相似地</p><p><code>Comparator&lt;Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());</code></p><p>可以写成</p><p><code>Comparator&lt;Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());</code></p><p>可以看到a1和a2的类型并没有给出，这两种写法都是可以的，选择哪种则看个人喜好。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/java>Java</a></li></ul></nav></div></article></main><footer><hr><a class=soc href=https://github.com/tomial title=Github><i data-feather=github></i></a>|⚡️
2021 © Tomial | Modified <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer><script>feather.replace()</script></div></body></html>